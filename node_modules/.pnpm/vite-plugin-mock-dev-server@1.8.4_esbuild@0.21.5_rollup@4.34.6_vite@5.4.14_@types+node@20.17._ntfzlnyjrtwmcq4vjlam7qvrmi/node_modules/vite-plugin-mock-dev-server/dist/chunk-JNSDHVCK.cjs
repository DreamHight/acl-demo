"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// src/core/defineMock.ts
var _utils = require('@pengzhanbo/utils');
function defineMock(config) {
  return config;
}
function createDefineMock(transformer) {
  const define = (config) => {
    if (_utils.isArray.call(void 0, config))
      config = config.map((item) => transformer(item) || item);
    else
      config = transformer(config) || config;
    return config;
  };
  return define;
}

// src/core/defineMockData.ts

var mockDataCache = /* @__PURE__ */ new Map();
var responseCache = /* @__PURE__ */ new WeakMap();
var staleInterval = 70;
var CacheImpl = class {
  
  // 初始化数据的备份，用于 判断 传入的初始化数据是否发生变更
  #initialValue;
  #lastUpdate;
  constructor(value) {
    this.value = value;
    this.#initialValue = _utils.deepClone.call(void 0, value);
    this.#lastUpdate = Date.now();
  }
  hotUpdate(value) {
    if (Date.now() - this.#lastUpdate < staleInterval)
      return;
    if (!_utils.deepEqual.call(void 0, value, this.#initialValue)) {
      this.value = value;
      this.#initialValue = _utils.deepClone.call(void 0, value);
      this.#lastUpdate = Date.now();
    }
  }
};
function defineMockData(key, initialData) {
  if (!mockDataCache.has(key))
    mockDataCache.set(key, new CacheImpl(initialData));
  const cache = mockDataCache.get(key);
  cache.hotUpdate(initialData);
  if (responseCache.has(cache))
    return responseCache.get(cache);
  const res = [
    () => cache.value,
    (val) => {
      if (_utils.isFunction.call(void 0, val))
        val = _nullishCoalesce(val(cache.value), () => ( cache.value));
      cache.value = val;
    }
  ];
  Object.defineProperty(res, "value", {
    get() {
      return cache.value;
    },
    set(val) {
      cache.value = val;
    }
  });
  responseCache.set(cache, res);
  return res;
}

// src/core/sse.ts
var _stream = require('stream');
var SSEStream = class extends _stream.Transform {
  constructor(req) {
    super({ objectMode: true });
    req.socket.setKeepAlive(true);
    req.socket.setNoDelay(true);
    req.socket.setTimeout(0);
  }
  pipe(destination, options) {
    if (destination.writeHead) {
      destination.writeHead(200, {
        "Content-Type": "text/event-stream; charset=utf-8",
        "Transfer-Encoding": "identity",
        "Cache-Control": "no-cache",
        "Connection": "keep-alive"
      });
      _optionalChain([destination, 'access', _ => _.flushHeaders, 'optionalCall', _2 => _2()]);
    }
    destination.write(":ok\n\n");
    return super.pipe(destination, options);
  }
  _transform(message, encoding, callback) {
    if (message.comment)
      this.push(`: ${message.comment}
`);
    if (message.event)
      this.push(`event: ${message.event}
`);
    if (message.id)
      this.push(`id: ${message.id}
`);
    if (message.retry)
      this.push(`retry: ${message.retry}
`);
    if (message.data)
      this.push(dataString(message.data));
    this.push("\n");
    callback();
  }
  write(message, ...args) {
    return super.write(message, ...args);
  }
};
function dataString(data) {
  if (typeof data === "object")
    return dataString(JSON.stringify(data));
  return data.split(/\r\n|\r|\n/).map((line) => `data: ${line}
`).join("");
}
function createSSEStream(req, res) {
  const sse = new SSEStream(req);
  sse.pipe(res);
  return sse;
}






exports.defineMock = defineMock; exports.createDefineMock = createDefineMock; exports.defineMockData = defineMockData; exports.createSSEStream = createSSEStream;
